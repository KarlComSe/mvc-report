{# templates/index.html.twig #}
{% extends 'base.html.twig' %}
{% block title %}Metrics analys{% endblock %}
{% block body %}
<main class="mt-3">
  <section>
    <h1>Clean code</h1>
    <p>På svenska.</p>
    <nav>
      <ul>
      <li><a href="#introduction">Introduktion</a></li>
      <li><a href="#phpmetrics">Phpmetrics</a></li>
      <li><a href="#scrutinizer">Scrutinizer</a></li>
      <li><a href="#improvements">Förbättringar</a></li>
      <li><a href="#discussion">Diskussion</a></li>
      </ul>
    </nav>
    <article id="introduction">
      <h2>Introduktion</h2>
      <p>Inom paradigment kodkvalitet finns något som kallas de sex C:na. Här förklarar jag vad de innebär och ger exempel kopplade till min kod, och de mätvärden / rapporter som Scrutinizer och phpmetrics genererar.</p>
      <ul>
        <li>Codestyle: Handlar om huruvida koden följer en kodstandard. Det finns olika kodstandarder, t.ex. <a href="https://www.php-fig.org/psr/psr-12/">PSR-12</a> och det går att använda verktyg såsom PHP code sniffer (PHP CS) för att gå igenom hur väl koden följer standarden. Denna webbplats använder PHP CS som är inställt på PSR-12 som kodstandard. Denna webbplats använder också PHP MD med en rad olika inställningar för kodstandard. Dessa och liknande verktyg fixar om möjligt koden och ger annars ofta info om problemen. I relation till Scrutinizer och phpmetrics, så kan man säga att det är förebyggande åtgärder. I mitt fall fick jag av dessa verktyg tidigare varning för hög komplexitet när jag gjorde kortspelet. Då gjorde jag om min kod. Hade jag inte gjort det, hade resultatet från PHP metrics och Scrutinizer gällande komplexitet varit betydligt högre. En definierad kodstandard kan hjälpa till att skapa mer robust kod eftersom det går snabbare att sätta sig in i någon annans kod och man använder "standardiserade" sätt att skriva kod på (t.ex. line endings, hur man ska skriva sina variabelnamn etc.), speciellt tillsammans med verktyg som fixar och synliggör avvikelser. </li>
        <li>
          Coverage: Är ett mått på hur mycket av koden som täcks av test. Båda verktygen visar olika mått på coverage. En hög kodtäckningsgrad kan ge en indikation på att koden är robust. Det förutsätter att testerna är bra skrivna. 
          <img src="{{ asset('images/pre_coverage_php_metrics.png') }}" alt="Mätetal för coverage visas via php metrics">
          <img src="{{ asset('images/pre_coverage_scrutinizer.png') }}" alt="Mätetal för coverage visas via scrutinizer">
        </li>
        <li>Complexity: Det finns olika sätt att mäta komplexitet, men ett sådant är cyklomatisk komplexitet (McCabe-tal). Det är kortfattat antalet möjliga exekveringsvägar i en klass / metod. En logik med nästlade if-satser skapar då en hög komplexitet. Andra sätt att mäta komplexitet är t.ex. beroende till eller från andra moduler / klasser / metoder (ev. överlapande med coupling), antalet rader kod, arvsdjup, etc. En hög komplexitet kan vara en indikation på att man bör överväga förändringar. Återigen finns det gott om exempel på kod som får en hög komplexitet men som knappast kan förenklas. 
          <img src="{{ asset('images/pre_complexity_phpmetrics.png') }}" alt="Mätetal för coverage visas via php metrics">
          <img src="{{ asset('images/pre_complexity_scrutinizer.png') }}" alt="Mätetal för coverage visas via scrutinizer"> 
        </li>
        <li>Cohesion: Handlar om beroendet inom en klass och hänger delvis ihop med begreppet single responsibility principle. Hög kohesion innebär att de interna elementen i en klass arbetar ihop för att lösa ett ansvarsområde. Har man låg kohesion så kan det vara svårt att sätta sig in i vad klassen faktiskt gör, eftersom metoderna / elementen i den inte hänger ihop. Det i sig leder till problem att underhålla koden, eftersom man glömmer av vad man gjorde strax efter att man gjort det. LCOM (lack of cohesive methods) är ett mätetal, som mäter antalet ansvarsområden en klass har. </li>
        <li>Coupling: Handlar om beroendet en klass har med andra delar av programmet. Att ha hög koppling innebär att man är beroende av andra delar av programmet. Det kan göra det svårt att underhålla sin kod, eftersom en ändring någonstans då har en större risk att påverka andra delar av programmet.</li>
        <li>Koppling och kohesion i PHP Metrics och Scrutinizer: Jag hittar begränsat med mätetal i Scrutinizer för detta. PHP Metrics visar upp lite olika mätetal för koppling, och även LCOM (lack of cohesive methods, där ett lågt tal är bra och högre tal är sämre). 
          <img src="{{ asset('images/pre_coupling_phpmetrics.png') }}" alt="Mätetal för coupling visas via php metrics">
          <img src="{{ asset('images/pre_cohesion_phpmetrics.png') }}" alt="Mätetal för cohesion visas via php metrics">
        </li>
        <li>CRAP: står för Change Risk Analyzer and Predictor eller Change Risk Anti Pattern. Det beräknas med hjälp av cyklomatisk komplexitet och testtäckning. Har man låg komplexitet och få test blir CRAP lågt, har man hög komplexitet och få test blir CRAP högt. Det går att ha hög komplexitet, men det kräver tester för att minska CRAP-score. 
          <img src="{{ asset('images/pre_crap_scrutinizer.png') }}" alt="Mätetal för CRAP visas via scrutinizer">
        </li>
      </ul>
    </article>
    <article id="phpmetrics"></article>
      <h2>Phpmetrics</h2>
      <p>
        I kapitlet introduktion finns lite olika mätetal från PHP Metrics rapport, där jag knyter ihop vad verktyget (PHP Metrics) visar och de 6 C:na. Här går jag in översiktligt på rapporten från PHP Metrics och även sådant som inte kom upp ovan. 
      </p>
      <p>
        Överblick för PHP metrics:
        <img src="{{ asset('images/pre_overview_phpmetrics.png') }}" alt="Mätetal för phpmetrics">
      </p>
      <p>
        Något som inte ser så bra ut är de violations som visas upp i överblicken. Dessa ingår inte direkt i kodkvalitén ovan.
        <img src="{{ asset('images/pre_violations_phpmetrics.png') }}" alt="Mätetal för violations visas via php metrics">
      </p>
      <p>
        Tittar jag vidare på komplexitet så finns det en del som sticker ut. Utan att försöka åtgärda är det svårt att säga om det är dåligt eller bra. 
        <img src="{{ asset('images/pre_complexity_overview_phpmetrics.png') }}" alt="Mätetal för complexity visas via php metrics">
      </p>
    </article>
    <article id="scrutinizer">
      <h2>Scrutinizer</h2>
      <p>
        I kapitlet introduktion finns lite olika mätetal från PHP Metrics rapport, där jag knyter ihop vad verktyget (Scrutinizer) visar och de 6 C:na. Här går jag in översiktligt på rapporten från Scrutinizer och även sådant som inte kom upp ovan.
      </p>
      <p>
        Lite olika överblick från Scrutinizer:
        <img src="{{ asset('images/pre_overview_1_scrutinizer.png') }}" alt="Mätetal för scrutinizer">
        <img src="{{ asset('images/pre_overview_2_scrutinizer.png') }}" alt="Mätetal för scrutinizer">
        <img src="{{ asset('images/pre_overview_3_scrutinizer.png') }}" alt="Mätetal för scrutinizer">
        <img src="{{ asset('images/pre_overview_4_scrutinizer.png') }}" alt="Mätetal för scrutinizer">
      </p>
      <p>Ett intressant mätetal som visas i första bilden är det  övergripande betyget "Scrutinizer code quality". Det är såklart roligt att det är nära 10, men koden är ju inte särskilt komplex och är gjord inom ett ramverk, så jag har svårt att säga om det är bra eller dåligt, men det ser ju på ytan i alla fall bra ut. </p>
      <p>
        Likaväl här hittar jag något som kallas issues (se bild två ovan). Det är inte heller något som specifikt kommer upp bland de 6 c:na. De är värda att undersöka och åtgärda om möjligt. Här valde jag en av de issues som fanns och djupdök i den med verktyget. Här kan vi ser mer i detalj vad den klagar på, och det verkar ju rimliga saker att åtgärda.
        <img src="{{ asset('images/pre_issues_scrutinizer.png') }}" alt="Mätetal för issues visas via scrutinizer">
      </p>
      <h3>Klickbara badges (från senaste bygget)</h3>
      <ul>
        <li><a href="https://scrutinizer-ci.com/g/KarlComSe/mvc-report/?branch=main"><img src="https://scrutinizer-ci.com/g/KarlComSe/mvc-report/badges/quality-score.png?b=main"></a></li>
        <li><a href="https://scrutinizer-ci.com/g/KarlComSe/mvc-report/?branch=main"><img src="https://scrutinizer-ci.com/g/KarlComSe/mvc-report/badges/coverage.png?b=main"></a></li>
        <li><a href="https://scrutinizer-ci.com/g/KarlComSe/mvc-report/?branch=main"><img src="https://scrutinizer-ci.com/g/KarlComSe/mvc-report/badges/build.png?b=main"></a></li>
        <li><a href="https://scrutinizer-ci.com/g/KarlComSe/mvc-report/?branch=main"><img src="https://scrutinizer-ci.com/g/KarlComSe/mvc-report/badges/code-intelligence.svg?b=main"></a></li>
      </ul>
    </article>
    <article id="improvements">
      <h2>Förbättringar</h2>
        <p>
          Jag avser att göra följande förbättringar:
        </p>
        <ul>
          <li><strong>Fixa flertalet av de issues som Scrutinizer identifierar:</strong> Jag väljer det här eftersom det ges konkreta tips på saker att åtgärda. Min förhoppning är att jag kan ta med mig detta till min kodning och undvika liknande i framtiden. Detta kommer få en direkt påverkan på detta mätetal, men jag vet inte vilken inverkan det har på andra mätetal.
            <ul>
              <li><strong>Resultat</strong>:Gick från 24 till 10 violations. Av de kvarstående violations berör 6 samma problem, som jag är osäker på hur jag ska fixa (The type Random\Randomizer was not found).</li>
              <li><strong>Förändringar</strong>: Jag hade en del jämförelser som var dåliga. Jag kollade om något var sant, och borde istället ha jämfört det mot !== null.</li>
              <li><strong>Kommentarer kring ev. kvarstående åtgärder / problem:</strong> Skulle behöva hjälp för att lösa resterande. Tror det är fullt möjligt.</li>
            </ul>
          </li>
          <li><strong>Fixa flertalet av de violations som PHP Metrics identifierar:</strong> Jag väljer det här eftersom det ges konkreta tips på saker att åtgärda. Min förhoppning är att jag kan ta med mig detta till min kodning och undvika liknande i framtiden.  Detta kommer få en direkt påverkan på detta mätetal, men jag vet inte vilken inverkan det har på andra mätetal.
            <ul>
              <li><strong>Resultat</strong>: Startade med 6 violations. Slutade med 4. </li>
              <li><strong>Förändringar</strong>: Hade en stor controller, delade upp den. Hade en harrang med if-satser för en <b>sorteringsalgoritm</b> som var lite komplicerad, där kunde jag ersätta 10 rader med 1 uppdaterad rad kod, tack vare nullish-coalescer (fick hjälp av Chat GPT, vilket för fungerade för en gångs skull).</li>
              <li><strong>Kommentarer kring ev. kvarstående åtgärder / problem:</strong> Gjorde en större refactoring, där jag försökte närma mig single responsibility principle i klassen DeckOfCards, delade upp den i flera. Min förhoppning var att ta bort ett error, "Blob / God object". Varningarna var för många publika metoder, hög kohesion och att klassen kände till mycket annat. Jag lyckades minska antalet publika metoder till 9. På köpet fick jag en hel del förbättrade andra betyg, men tyvärr kvarstår "Blob / God object". Eftersom klassen implementerar Observer-pattern är jag tvungen att implementera ca 6 publika funktioner, vilka också arbetar med olika attribut, jämfört med klassens huvuduppgift. Detta bidrar till den höga kohesionen, antalet metoder samt även att den blir God object. Det finns tre andra violations som är kvar, den ena är att en klass är "probably bugged", det är en av mina spelklasser. Den innehåller 0.42 buggar. Min uppfattning är att den är okej ändå, den har en del tester och innehåller en hel del spellogik med flertalet conditionals / switch-satser. Ev. skulle jag kunna få ner den utan större insats, men jag la all min tid på tidigare problem och tycker inte att 0.42 buggar i denna klass är bekymmersamt. De två övriga violations är klasser som jag inte gjort, och jag lämnar de.</li>
            </ul>
          </li> 
          <li>
            <strong>Jag avser också att minska på komplexiteten som rapporteras i Scrutinizer.</strong> App\Model\Game, App\Model\DetermineWinner, App\Model\DeckOfCards och App\Model\FrenchSuitedDeck har en komplexitet på 40, 22, 19 resp. 16. Jag anar att det kan vara svårt att minska på komplexiteten i Game, men jag väljer att undersöka dessa. Det går också att se i överblicken ovan att PHP Metrics rapporterar en hög komplexitet, där blir det dock nedan resultat. Jag får kika på de också. Jag väljer att angripa komplexitet därför att det är en av de 6 c:na, och jag skulle vilja se vad som behöver göras.
            <img src="{{ asset('images/pre_complexity_overview_improvements_phpmetrics.png') }}" alt="Mätetal för complexity visas via php metrics"> 
            <ul>
              <li><strong>Resultat</strong>: Slutresultat: från en total komplexitet på de fyra utvalda klasserna på 97 till 75. Även rejäl minskning i dashboarden på PHP Metrics.
              <img src = "{{ asset('images/post_complexity_overview_improvements_phpmetrics.png') }}" alt="Mätetal för complexity visas via php metrics">
            </li>
              <li> <strong>Förändringar</strong>: 
                Förändringar från tidigare åtgärder har bidragit till att minska komplexiteten. Komplexiteten landade först på 40, 22, 10 och 10. FrenchSuitedDeck har alltså gått från 16 till 10. DeckOfCards har gått från 19 till 10. Det beror i huvudsak på 1) att jag gjorde om en sorteringsalgoritm från 10 till 1 rad och 2) att jag närmade mig single responsibility principle (delade upp en klass). Men kan jag göra något för att minska komplexiteten i Game och DetermineWinner? Låt mig kolla. Ja, sätt en metod till private i Game, men påverkar det Scrutinizer? Nja, tror inte det, men kanske kollade jag på fel ställe. Min "Game"-klass innehåller logik för att göra flera saker, den hanterar bl.a. spelhändelser och validerar form submission. Här kan jag bryta ut valideringen av formuläret (användarinput) till en separat klass. Blev det något bättre? Ja, nu är komplexiteten nere på 37. För DetermineWinner, så hittar jag ganska snabbt två metoder som filtrerar arrayer, på olika sätt. Här borde jag kunna använda PHPs inbyggda funktioner, det bör definitivt ge utslag. Tiden går och jag använder chatGPT för att få förslag på getPlayersBestScores samt getAllHighestScore, kanske blir koden lite mindre läsbar för mig som inte har alla PHPs funktioner i ryggmärgen, men låt gå, det ser rätt ut och går att förstå. Testerna fungerar och spelet med. Komplexiteten gick ner till 18. Låt gå. </li>
              <li><strong>Kommentarer kring ev. kvarstående åtgärder / problem: </strong>Jag kan inte säga  mycket om komplexiteten är hög, låg eller acceptabel. Det finns en kvarstående komplexitet eftersom klasserna innehåller conditionals. Jag kan inte helt ta bort de eftersom det är en del av programlogiken. Ovan har jag visat att det går att minska komplexiteten avsevärt främst genom att närma mig single responsibility principle och använda PHPs inbygda funktioner (istället för att definiera egna).</li>
            </ul>
          </li>
        </ul>
        </p>
      </article>
    </article>
    <article id="discussion">
      <h2>Diskussion</h2>
      <ul>
      <li><strong>Kan man aktivt jobba med kodkvalitet och “clean code” på detta sättet?</strong>: Man kommer långt med dessa verktyg. Förstår man ungefär vad de klagar på så kan man få input, genom att läsa på om mätetalen och fråga diverse AIs om hur ens kod kan göras om för att påverka mätetalen. På så sätt har åtminstone jag lärt mig en del.</li>
      <li><strong>Finns det fördelar och kanske nackdelar med att jobba med CI och statisk kodanalys med hjälp av dessa verktyg?:</strong> Har man riktigt kass kod så kommer verktygen att regaera, och det är ju bra, för den kassa koden kan t.ex. vara svår att underhålla eller full av buggar. Två problem med detta arbetssätt är att åtminstone jag blir styrd av att jaga förbättringar, snarare än att förstå hur jag bör skriva bra kod, och att jakten på förbättringar kan ta väl mycket tid för småsaker. Man behöver begränsa sig. </li>
      <li><strong>Ser du andra möjligheter att jobba mot “clean code”?:</strong> Jag tror att man kommer väldigt långt med grundläggande förståelse kring SOLID och DRY. Min upplevelse av verktygen (om man inkluderar PHP MD och PHP CS) är att många problem kommer ifrån att man inte jobbar i linje med dessa principer. Det är lätt att fixa en hel del hygienfaktorer på koden, som påvisas med verktygen, t.ex. oanvänd kod, dåliga variabelnamn (i viss utsträckning), men det är svårare att skapa förståelse för SOLID med hjälp av verktygen. Genomgångarna vi har haft har skapat en viss förståelse men man måste öva. Jag tror att detta är en bra ingång, här får man öva lite, men lite gamification och enkla projekt hade varit bra för att ytterligare förstärka förståelsen kring clean code (t.ex. få en klass som man ska göra om enligt SRP, ta bort beroenden osv.). Som med det mesta andra så är min upplevelse att man behöver ta det stegvis, och detta är ett möjligt steg bland alla tänkbara vägar. Det går ju att läsa boken Clean code, men det hjälper inte själv, för åtminstone jag måste öva.</li>
      </ul>
    </article>
    </article>
</main>
{% endblock %}