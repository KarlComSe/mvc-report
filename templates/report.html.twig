{# templates/index.html.twig #}
{% extends 'base.html.twig' %}
{% block title %}Redovisningstexter{% endblock %}
{% block body %}
<main class="mt-3">
  <section>
    <h1>Redovisningstexter</h1>
    <p>På svenska.</p>
    <nav>
      <ul>
        <li><a href="#kmom01">KMOM01</a></li>
        <li><a href="#kmom02">KMOM02</a></li>
        <li><a href="#kmom03">KMOM03</a></li>
        <li><a href="#kmom04">KMOM04</a></li>
        <li><a href="#kmom05">KMOM05</a></li>
        <li><a href="#kmom06">KMOM06</a></li>
        <li><a href="#kmom10">KMOM10</a></li>
      </ul>
    </nav>
    <article id="kmom01">
      <h2>KMOM01</h2>
      <h3>Förkunskaper om objektorientering</h3>
      <p>I Python-kursen som jag tog på BTH under LP2 2023, OOP, berörde vi objektorienterad programmering. Jag har tidigare studerat objektorienterad programmering i JAVA, men det var 2009. En överlag positiv erfarenhet. Mitt minne gällande de teoretiska konstruktionerna och även att praktiskt följa ett strikt objekt-orienterat paradigm lämnar lite att önska, t.ex. vad är polymorfism, vad är the Law of Demeter, vad är fördelarna med OO vs. procedural coding? </p>
      <h3>PHPs modell för klasser och objekt</h3>
      <p></p>
      <p>PHP har ett väl utbyggt stöd för objektorienterad programmering med hjälp av klasser och objekt. Den mest grundläggande syntaxen är:</p>
      <ul>
        <li>Definiera en klass: class KlassNamn {}</li>
        <li>Konstruktorer och destruktorer: public function __construct($param1, ...) {}</li>
        <li>Metoder: class KlassNamn { ... public function methodName() {}}</li>
        <li>Egenskaper: class KlassNamn { public $egenskap;}</li>
        <li>Skapa statiska metoder: public static function statiskMetod(){}</li>
        <li>Komma åt en statisk metod eller egenskap: minKlass::statiskMetod()</li>
        <li>Synlighet på egenskaper och metoder: public, protected, private</li>
        <li>Skapa object: $mittObj = new KlassNamn($param1, ...)</li>
        <li>Komma åt publika egenskaper: $mittObj->egenskap </li>
        <li>Komma åt egenskaper och metoder från den egna instansierade klassen (dvs. objektet): $this->... </li>
      </ul> 
      <p>PHP har koncept för abstrakta klasser, interface, traits och magiska funktioner.</p>
      <h3>Reflektion över kodbasen</h3>
      <p>Det grundläggande känns igen från Express / FLASK. Det verkar vara ett vedertaget mönster att ha vyer (templates), controllers och routes. I Symfony deklareras routingen i controllers. Jag är nöjd med min struktur.</p>
      <p>
        Det är en hel del saker jag inte förstår, t.ex. hur kan jag ha en konstruktor i en controller, med ett argument av en viss typ, där jag aldrig behöver instansiera det? (Se IndexController). Jag försökte <a href="https://symfony.com/doc/current/controller/service.html">registrera en controller som en service </a> och använda den i en annan controller, men lyckades inte.  
      </p> 
      <h3>Artikeln (boken?) “PHP The Right Way”</h3>
      <p>Med tanke på artikeln “PHP The Right Way”, vilka delar in den finner du extra intressanta och värdefulla? Är det några särskilda områden som du känner att du vill veta mer om? Lyft fram några delar av artikeln som du känner mer värdefulla.</p>
      <p>Jag vill lära mig mer om allt. Jag har bara skummat från testning och framåt. Dependency injection var ett intressant objekt-orienterat koncept som introducerades i boken, och jag ser fram emot att använda det praktiskt. Jag tycker att kapitlet som handlade om <a href="https://phptherightway.com/#web_application_security">säkerhet</a> var bra, då det på ett övergripande plan beskrev vilka olika områden man behöver ha koll på. </p>
      <h3>TIL</h3>
      <p>Vilken är din TIL för detta kmom?</p>
      <p>Jag har tidigare inte förstått vad :: betytt i PHP. Det är ett TIL.</p>
      <p>Jag lärde mig också att HTTP2 / HTTP3 inte längre kräver att man bundlar olika filer eller komprimerar filerarna med hjälp av minifiering. D.v.s. jag behöver skrota alla ställen där jag använder HTTP1.</p>
    </article>
    <article id="kmom02">
      <h2>KMOM02</h2>
      <h3>Objektorienterad (OO) programmering i PHP</h3>
      <p>Inom OO programmering finns ett antal koncept och här förklarar jag några av de, i synnerhet med fokus på PHP. Ett centralt paradigm inom OO är objekt. Ett objekt är en instansiering av en klass. En något haltande liknelse är att en klass är en husritning och att det bygda huset är en instans av klassen, d.v.s ett objekt. Att det haltar något beror på att en klass kan ha egna egenskaper och metoder, de kallas statiska.</p>
      <ul>
        <li>Arv är att man skapar en klass som ärver från en annan. På så sätt är det möjligt att t.ex. ha en generell klass som ärvs till något som är mer specifikt. Exempel är att man definierar en klass som fordon, och klasser såsom motorcykel, bil, lastbil, båt etc. som ärver egenskaperna från fordon. Det som är bra är att man vet att alla egenskaper och metoder från den ärvda klassen också finns i den klassen som ärver.</li>
        <li>Komposition är en beskrivning av en relation mellan två olika klasser. Komposition handlar om att ett objekt består av andra objekt. För att det ska kallas komposition så krävs att objekten som tillhör ett annat objekt är starkt knutna till det andra objektet och bara samexisterar med det andra objektet. Exempel på komposition är att ett hus har rum. Tar man bort huset finns inte rummen kvar. </li>
        <li>Ett interface är ett sätt beskriva krav på klasser som implementerar interfacet. En liknelse är t.ex. KRAV-märkning, för att bli KRAV-märkt finns det ett par krav som måste uppfyllas. I OO-världen beskrivs istället vad en klass måste implementera, t.ex. vissa funktioner. Om ett objekt då implementerar ett interface kan man vara säker på att den har vissa metoder. Ett exempel skulle kunna vara att en klass implementerar serializable, vilket är ett interface som kräver att klassen ska ha metoderna serialize och unserialize.</li>
        <li>Trait är en OO-konstruktion som finns bl.a. i PHP. Ett arv kräver att man ärver från en klass, vilken sen kan ärva till en annan o.s.v. Trait är lite som arv, man kan "ärva" funktionalitet till en klass från en eller flera traits, utan att skapa en arvs-hierarki.</li>
      </ul>
      <h3>Implementation</h3>
      <p>
        Jag är överlag nöjd med min implementation. Jag har fått experimentera med några OO-koncept och Symfony's sätt att implementera dessa. Jag fick överge ett par konstruktioner på grund av att jag inte förstod, likväl, kände att det var dags att gå vidare. Kanske kan återkomma till de senare. Det finns förbättringsmöjligheter, några av de knutna till tidigare mening: 
      </p>
      <ul>
        <li>Publika metoder och egenskapr / attribut: När jag skapade mitt API blev jag tvungen att ändra synligheten på mina attribut. Privata attribut i en klass blir inte synliga när man väljer att göra JSON av ett objekt av den klassen. Det fanns vägar runt, men jag behöver gå vidare till andra kurser och bli klar.</li>
        <li>Implementation av serializable-interfacet och vad som sparas till sessionen: Jag lyckades inte spara mitt objekt till sessionen. Jag testade att implementera serializable-interfacet, men det fungerade tyvärr inte så som jag ville. Jag har således valt att spara den array som innehåller en lista av kort i sessionen. En nackdel med detta är att min kortlek innehåller andra attribut, t.ex. om den har blivit blanadad, om några kort har blivit slängda etc.</li>
        <li>Dependency injection av bl.a. Randomizer och Observers: Jag har valt att injecta några beroenden, i mina klasser. Dessa behöver injectas igen när man hämtar från sessionen. Jag tycker att det blev sådär, men främst för att jag ville testa.</li>
        <li>100 % användning av APIt även på den vanliga sidan. Det är en dubbel uppsättning kod mellan APIt och /card-sidan. Detta då jag gjorde APIt efteråt. Det är fullt möjligt att använda APIt till att generera sidorna.</li>
        <l>Type hinting: Jag har inte konsekvent använt type hinting, för variabler eller retur-typer. Det är något som jag gärna gör och som jag får förbättra framöver.</l>
        </ul>
      <h3>Reflektioner</h3>
      <p>Överlag intressant KMOM. Jag har testat på ett par av de OO konstruktioner som finns i PHP, liksom använt mig av olika designmönster. Jag tycker det blev snyggt med observer designmönster på min kortlek. Jag tycker också användningen av eventlyssnare för att säkerställa att det finns en kortlek på relevanta routes, innan de laddas, är snyggt.</p>
      <p>Kan inte riktigt påstå att jag hittat helt rätt när saker och ting inte fungerar som tänkt än. Mina böcker likväl PHPs och Symfony's dokumentation lämnar en del att önska för mig som ännu inte är fullt bekväm med språket eller ramverket.</p>
      <h3>TIL</h3> 
      <p>Jag har lärt mig använda design-mönstret Observer. Jag har också felsökt en del med echo, dump, print_r och gettype. Man kommer ganska långt av det.</p>
    </article>
    <article id="kmom03">
      <h2>KMOM03</h2>
      <h3>Modellering</h3>
      <p>Det gick bra att modellera och var effektivt att bygga programmet utefter modelleringen. Det gjorde att jag snabbt kunde bygga ett fungerande program. Vad jag däremot missade var t.ex. single responsibility principle, polymorfism framför conditionals etc.</p>
      <h3>Implementation</h3>
      <p>Jag löste "snabbt" uppgiften initialt efter vad jag tänkt. Jag blev sen missnöjd med koden. Jag hade t.ex. hårdkodat spelare, och kollade sen om en spelare var bank eller människa. Jag ville undvika detta kollande och även ge banken möjlighet att själv styra sina drag, så jag skapade en klass för Player. Jag ärvde den klassen för BankPlayer och HumanPlayer. BankPlayer implementerade sen också AiPlayerInterface, som innehåller en metod för att bestämma en action. Just kring detta är jag väldigt nöjd. Det bidrog till att vissa jobbiga fel från lintingen försvann, som handlade om komplexitet och antalet exekveringsvägar. Jag är också nöjd över hur jag löste många andra av varningara som lintingen gav, t.ex. hög komplexitet.</p>
      <p>Jag fortsatte att utforska event-lyssnare och observer-pattern, i ett Symfony-kontext. Det tycker jag fungerar bra.</p>
      <p>När jag skapade fler klasser, Player, så blev spelet mer generellt, men för att få ihop det så gjrode jag en hel del fullösningar på sina ställen, eftersom jag vet att det bara är två spelare. Det här är definitivt ett förbättringsområde.</p>
      <p>Några andra förbättringsområden: 1) minska klass-storleken på t.ex. Game. Jag har inte varit fullt införstådd i Single Responsibility principle, och den här klassen kan minskas än mer, tänker jag. 2) PHP stan klagar en del (från början 90 plus, nu kan jag få ner det till 10, men väljer att stanna på 11). 3) PHP MD klagar också, framför allt kring att jag använder static access till klasser. Det skapar hårdkodade beroenden, säger förklaringarna. Jag får fortsätta utforska detta framöver när jag lär mig mer om dependency injection och dependency injection prinicple.</p>
      <h3>Symfony</h3>
      <p>Det är fortsatt viss magi i hur Symfony fungerar. Jag har sett att det finns en hel del coola features, t.ex. kring formulär, som hade varit användbara i den här uppgiften.</p>
      <h3>TIL</h3>
      <p>Single responsibility principle börjar gå upp för mig.</p>
      <p>Jag har fått en förståelse hur jag kan bygga en app där jag sparar ett state. </p>
      <p>Jag har lärt mig hur enkelt det är att lyfta ut logik från router / controller till egen klass.</p>
    </article>
    <article id="kmom04">
      <h2>KMOM04</h2>
      <p></p>
    </article>
    <article id="kmom05">
      <h2>KMOM05</h2>
      <p></p>
    </article>
    <article id="kmom06">
      <h2>KMOM06</h2>
      <p></p>
    </article>
    <article id="kmom10">
      <h2>KMOM10</h2>
      <p></p>
    </article>
</main>
{% endblock %}